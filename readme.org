#+TITLE: Mitch Kyle's Emacs 26 Configuration
#+AUTHOR: Mitch Kyle
#+EMAIL: mitch.tux@gmail.com

* What's All This Then?
This is a configuration file for emacs.

Inspired by [[http://aaronbedra.com/emacs.d/][Aaron Bedra's config]] with many elements taken from [[https://github.com/bbatsov/prelude][prelude]].

This is a [[https://en.wikipedia.org/wiki/Literate_programming][literate program]] which is intended to sit at =~/.emacs.d/readme.org= and
compile to =~/.emacs.d/init.el=. The file can be recompiled by running =mkyle/rebuild-init-file=.
The initialization sequence should check if this file has changed and if it has, then recompile
and load the new file as early as possible.

This file is named =readme.org= so it will show up on the github repo landing page and the idea of
having a literate program called "readme" amuses me slightly.

The language in this document is informal written as me the writer to you the reader (who is
probably me in the future /shout-out)

** Installation
pretty straight-forward
#+begin_src
git clone https://github.com/mitch-kyle/mkyle-emacs.git ~/.emacs.d
#+end_src

** Questions?
One of the purposes of this document is to provide information along with the configuration. It was however,
hastily written. I suspect a lot of it does not make sense. Feel free to open issues asking for clarification
or pointing out typos or nonsense and I'll try to help and improve the document as I go.

* Platform
Things that inform the rest of the configuration. "How things are done" sort of stuff.

** File Header
Things we want to happen immediately before loading package management and use-package
Add an emacs lisp header to the generated file with an explaination that it is a generated file
#+begin_src emacs-lisp
;;; init.el --- emacs initialization -*- lexical-binding: t; -*-
;;; Commentary:
;; This file was generated. do not edit. changes may be overwritten
;;; Code:
#+end_src

** Early Init
Things we want to do before package management and org mode are loaded

*** Garbage Collection
Garbage collect every 100MB of allocated data rather than the low default
#+begin_src emacs-lisp
(setq-default gc-cons-threshold 104857600)
#+end_src

*** Short Answers
Use 'y' or 'n' rather than 'yes' or 'no'. This should improve productivity when answering binary questions by up
to 60% according to homer simpson.

Seems like this wasn't being applied for some thing so let's put it in early init to see if that fixes it.
#+begin_src
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Start The Server
Start the emacs server so emacsclient can be used with this session
#+begin_src emacs-lisp
(server-start)
#+end_src

** Package Manager - straight.el
A functional package manager for emacs. See [[https://github.com/raxod502/straight.el][straight.el github]]
#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
       'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

** Package Configuration - use-package
[[https://github.com/jwiegley/use-package][use-package]] is a package configuration tool with many features. One nice one is that it contains failures
and does't prevent the rest of your configuration from loading. Set it to use straight.el by default.
#+begin_src emacs-lisp
(setq straight-use-package-by-default t)
(straight-use-package 'use-package)
#+end_src

** Org Mode
 Org mode is used to build this document so we're going load it as early as we can to prepare for
 rebuilding the configuration files

*** straight.el Workaround
Because straight.el can't properly compile org yet, we need to define the org-version function
ourselves to prevent the old builtin org from being loaded instead.
 #+begin_src emacs-lisp
 (use-package git)
 (when (require 'git nil t)
   (defun org-git-version ()
     "The Git version of org-mode.
 Inserted by installing org-mode or when a release is made."
     (let ((git-repo (expand-file-name "straight/repos/org/"
               user-emacs-directory)))
       (string-trim
   (git-run "describe"
      "--match=release\*"
      "--abbrev=6"
      "HEAD"))))

   (defun org-release ()
     "The release version of org-mode.
 Inserted by installing org-mode or when a release is made."
     (let ((git-repo (expand-file-name "straight/repos/org/"
               user-emacs-directory)))
       (string-trim
  (string-remove-prefix
   "release_"
   (git-run "describe"
      "--match=release\*"
      "--abbrev=0"
      "HEAD")))))

   (provide 'org-version))
 #+end_src

*** Org Configuration
Load org, nothing fancy
 #+begin_src emacs-lisp
 (use-package org
   :mode ("\\.org\\'" . org-mode))
 #+end_src

** Compiling this File
A function to rebuild this file if it's changed since the last time it was built.
#+begin_src emacs-lisp
(when (require 'org nil t)
  (defun mkyle/rebuild-init-file ()
    "Rebuild init file if it's changed since the last time it was built."
    (interactive)
    (let ((source-file    (expand-file-name "readme.org" user-emacs-directory))
    (generated-file (expand-file-name "init.el" user-emacs-directory)))
      (when (org-file-newer-than-p source-file
           (file-attribute-modification-time
             (file-attributes generated-file)))
  (org-babel-tangle-file source-file generated-file "emacs-lisp")
  (byte-compile-file generated-file)
  t))))
#+end_src

Check for changes. If there are then load the new file and stop load this file.
#+begin_src emacs-lisp
(when (and (functionp 'mkyle/rebuild-init-file)
     (mkyle/rebuild-init-file))
    (load (expand-file-name "init.elc" user-emacs-directory))
    (error (concat "Loaded from dirty config. "
       "This isn't likely to cause problems and should be "
       "fix when emacs is restarted. "
       "Thought you aught to know.")))
#+end_src

*** TODO Recompile on save
*** TODO Script to Build from Stock Emacs

* Manage Config Directory
** No Litter
Keep =~/.emacs.d= clean. some libraries create variable files and/or additional configuration files
in the emacs user directory; no-littering puts most of these files in =~/.emacs.d/var= and =~/.emacs.d/etc=
respectively.
#+begin_src emacs-lisp
(use-package no-littering)
#+end_src

** Custom
Use a separate file for custom modifications so they are not overwritten in init.el
#+begin_src emacs-lisp
(with-eval-after-load "no-littering"
  (setq-default custom-file (expand-file-name "custom.el" no-littering-etc-directory))
  (when (file-exists-p custom-file)
    (load custom-file t)))
#+end_src

*** TODO Put custom in
* Look And Feel
** Mode Line
The modeline displays information about the buffer like buffer name and what modes are currently active between the window and the minibuffer

*** Hide Minor Modes
Modeline is for showing all the active modes. Some of these are not useful so let's hide them.
This adds the =:diminish= key to =use-package= which will hide the minor-mode associated with the package.
#+begin_src emacs-lisp
(use-package diminish)
#+end_src

*** Search Results
Show total number of search matches and the current match index in the modeline
See [[https://github.com/syohex/emacs-anzu][emacs-anzu]]
#+begin_src emacs-lisp
(use-package anzu
  :diminish anzu-mode
  :config (global-anzu-mode))
#+end_src

*** Buffer Information
Show buffer size
#+begin_src emacs-lisp
(size-indication-mode t)
#+end_src

Show cursor position in buffer
#+begin_src emacs-lisp
(line-number-mode t)
(column-number-mode t)
#+end_src

** Fonts
[[http://terminus-font.sourceforge.net/][Terminus Font]] is designed for terminals and source code.
#+begin_src emacs-lisp
(set-frame-font "xos4 Terminus 12")
#+end_src

Add font with better unicode coverage.
#+begin_src emacs-lisp
(when (member "Symbola" (font-family-list))
  (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+end_src

** Ease Of Use
These don't really fit anywhere else but they are essential to make emacs not feel ancient and esoteric

*** Remove Startup Clutter
The startup screen has some nice information for new users but it's in the way.
Same with the scratch buffer explaination

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      initial-scratch-message nil)
#+end_src

*** Large File Warning
warn when opening files bigger than 100MB
#+begin_src emacs-lisp
(setq-default large-file-warning-threshold 104857600)
#+end_src

*** Maximize Screen Space
Remove the various bars taking up valuable working space
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

*** Disable Blinking Cursor
In theory the blinking cursor could be a conservation tool; consume only half of the power of a static cursor.
In practice, it's just a pain.
#+begin_src
(blink-cursor-mode -1)
#+end_src

*** Show Keybindings
show available keybindings after you start typing
#+begin_src emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config (which-key-mode +1))
#+end_src

*** Open File At Point
Open file with emacsclient with cursors positioned on requested line.
Most of console-based utilities prints filename in format
'filename:linenumber'.  So you may wish to open filename in that format.
Just call:
#+begin_src
emacsclient filename:linenumber
#+end_src

and file 'filename' will be opened and cursor set on line 'linenumber'
From: [[https://github.com/bbatsov/prelude][prelude]]

#+begin_src emacs-lisp
(defadvice server-visit-files (before parse-numbers-in-lines (files proc &optional nowait) activate)
  "Open file with emacsclient with cursors positioned on requested line.
Most of console-based utilities prints filename in format
'filename:linenumber'.  So you may wish to open filename in that format.
Just call:

  emacsclient filename:linenumber

and file 'filename' will be opened and cursor set on line 'linenumber'"
  (ad-set-arg 0
        (mapcar (lambda (fn)
      (let ((name (car fn)))
        (if (string-match "^\\(.*?\\):\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?$" name)
          (cons
            (match-string 1 name)
            (cons (string-to-number (match-string 2 name))
            (string-to-number (or (match-string 3 name) ""))))
          fn)))
          files)))
#+end_src

*** Titles
**** Set Frame Title Format
The frame is the whole external "emacs window", not to be confused with a window within emacs which displays
a buffer. An emacs instance may have multiple frames and a frame may have multiple windows. This sets the
title of the window to the filename of the active buffer if available otherwise the buffer name.

#+begin_src emacs-lisp
(setq frame-title-format
      '("" invocation-name " - "
  (:eval (if (buffer-file-name)
       (abbreviate-file-name (buffer-file-name))
     "%b"))))
 #+end_src

**** Buffer Titles
Rename buffers with the same file name to something useful
#+begin_src emacs-lisp
(when (require 'uniquify nil t)
  (setq uniquify-buffer-name-style   'forward
  uniquify-separator           "/"
  ;; rename after killing uniquified
  uniquify-after-kill-buffer-p t
  ;; ignore system buffers
  uniquify-ignore-buffers-re   "^\\*"))
#+end_src

*** Reload When Files Change
Revert buffers automatically when underlying files are changed externally
#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src

*** Save Command History
Save most recently run commands and text searches
#+begin_src emacs-lisp
(when (require 'savehist nil t)
  (setq savehist-additional-variables
  '(search-ring regexp-search-ring)
  ;; save every minute
  savehist-autosave-interval 60)
  (savehist-mode +1))

;; smex, remember recently and most frequently used commands
(use-package smex
  :config (progn
      (smex-initialize)
      (global-set-key (kbd "M-x") 'smex)
      (global-set-key (kbd "M-X") 'smex-major-mode-commands)))
#+end_src

*** Splitting Windows
Prefer to split veritcally rather than horizontally. Shamelessly stolen from stack overflow years ago.
#+begin_src emacs-lisp
(defun mkyle/split-window (&optional window)
  "Split window more senibly.  WINDOW."
  (let ((window (or window (selected-window))))
    (or (and (window-splittable-p window t)
       ;; Split window horizontally.
       (with-selected-window window
         (split-window-right)))
  (and (window-splittable-p window)
       ;; Split window vertically.
       (with-selected-window window
           (split-window-below)))
  (and (eq window (frame-root-window (window-frame window)))
       (not (window-minibuffer-p window))
       ;; If WINDOW is the only window on its frame and is not the
       ;; minibuffer window, try to split it horizontally disregarding
       ;; the value of `split-width-threshold'.
       (let ((split-width-threshold 0))
         (when (window-splittable-p window t)
     (with-selected-window window
       (split-window-right))))))))

(setq split-window-preferred-function #'mkyle/split-window)
#+end_src

*** Finding the Cursor
Show the cursor when moving after big movements in the window
#+begin_src emacs-lisp
(use-package beacon
  :diminish beacon-mode
  :config (beacon-mode +1))
#+end_src

*** Executible Path
Set the path to the enviroment variable PATH always
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config (exec-path-from-shell-initialize))
#+end_src

** Navigation
*** List Buffers - IBuffer
List buffers with C-x C-b. The default emacs buffer list isn't very helpful; IBuffer is a good alternative.
#+begin_src  emacs-lisp
(when (require 'ibuffer nil t)
  (global-set-key (kbd "C-x C-b") 'ibuffer))
#+end_src

**** IBuffer Columns
Setup the buffer list columns to show more of the name
#+begin_src  emacs-lisp
(with-eval-after-load "ibuffer"
  (setq ibuffer-formats
  '((mark modified read-only " "
     (name 40 40 :left :elide) " " ;; 40 40 is the column width
     (size 9 -1 :right) " "
     (mode 8 8 :left :elide) " "
     filename-and-process)
    (mark " " (name 16 -1) " " filename))))
#+end_src

**** IBuffer Filter Groups
Organize the list of buffers by group. Dynamic groups allow this list to be generated and for it to be extended
by other packages (like ibuffer-projectile)
#+begin_src emacs-lisp
(with-eval-after-load "ibuffer"
  (setq ibuffer-show-empty-filter-groups nil)

  (with-eval-after-load "straight"
    (use-package ibuffer-dynamic-groups
      :straight (ibuffer-dynamic-groups :type git
    :host github
    :repo "mitch-kyle/ibuffer-dynamic-groups")
    :config (progn
        (ibuffer-dynamic-groups-add
          (lambda (groups)
      (append groups
        '(("System" (name . "^\\*.*\\*$")))))
          '((name . system-group)))
        (ibuffer-dynamic-groups t)))))
#+end_src

*** Ido
Better interactive mini-buffer menus. highly recommend
See [[http://ergoemacs.org/emacs/emacs_ido_mode.html][ergomacs ido tutorial]]

#+begin_src emacs-lisp
(use-package ido
  :config (progn
    (setq ido-enable-prefix                      nil
    ido-enable-flex-matching               t
    ido-create-new-buffer                  'always
    ido-use-filename-at-point              'guess
    ido-max-prospects                      10
    ido-default-file-method                'selected-window
    ido-auto-merge-work-directories-length -1)
    (ido-mode +1)

    (use-package ido-completing-read+
      :config (ido-ubiquitous-mode +1))

    ;; smarter fuzzy matching for ido
    (use-package flx-ido
      :config (progn (flx-ido-mode +1)
         ;; disable ido faces to see flx highlights
         (setq ido-use-faces nil)))))
#+end_src

*** Windmove
Switch windows in the direct of the arrow keys. (s-<arrow>)
#+begin_src emacs-lisp
(when (require 'windmove nil t)
  (global-set-key [s-left]  'windmove-left)
  (global-set-key [s-right] 'windmove-right)
  (global-set-key [s-up]    'windmove-up)
  (global-set-key [s-down]  'windmove-down))
#+end_src

*** TODO hippie-expand
*** TODO flyspell
** Editing
*** Projectile
A set of commands for editing files as part of a project
#+begin_src emacs-lisp
(use-package projectile
  :config (progn
      (projectile-mode t)
      (global-set-key (kbd "C-c p") projectile-command-map)))
#+end_src

**** Projectile IBuffer Groups
Group files by project in ibuffer
#+begin_src emacs-lisp
(with-eval-after-load "projectile"
  (with-eval-after-load "ibuffer-dynamic-groups"
    (use-package ibuffer-projectile
      :config (progn
    (setq ibuffer-projectile-prefix "- ")
    (ibuffer-dynamic-groups-add (lambda (groups)
                (append (ibuffer-projectile-generate-filter-groups)
                  groups))
              '((name . projectile-groups)
                (depth . -50)))))))
#+end_src

*** Tramp
Tramp is useful for editing files on remote systems or for editing files as a different user such as root
#+begin_src emacs-lisp
(with-eval-after-load "tramp"
  (setq tramp-default-method "ssh"))
#+end_src

*** Recent Files
Track recently opened files to have them quickly on-hand. see recentf-open-files.
Exclude files in the variable directory.
#+begin_src emacs-lisp
(when (require 'recentf nil t)
  (setq recentf-max-saved-items 500
  recentf-max-menu-items 15
  ;; disable recentf-cleanup on Emacs start, because it can cause
  ;; problems with remote files
  recentf-auto-cleanup 'never)

  (defun mkyle/recentf-exclude-p (file)
    "A predicate to decide whether to exclude FILE from recentf."
    (string-prefix-p (file-truename no-littering-var-directory)
   (file-truename (file-name-directory file))))

  (add-to-list 'recentf-exclude 'mkyle/recentf-exclude-p)
  (recentf-mode +1))
#+end_src

*** Sane Basic Editing Keybindings
Make C-[x,c,v] work how you would expect in a text editor. /with-love
#+begin_src emacs-lisp
(cua-mode t)
#+end_src

*** Rainbow Delimiters
Give nested delimiters (=()[]{}<>=) different colours. It is more valuable than gold

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

*** Line Numbers
Always show line numbers
#+begin_src emacs-lisp
(global-linum-mode t)
#+end_src

*** Scrolling
Maintain cursor position when scrolling
#+begin_src emacs-lisp
(setq scroll-margin                   0
      scroll-conservatively           100000
      scroll-preserve-screen-position 1)
#+end_src

*** Tab Behaviour
Use spaces instead of tabs
#+begin_src emacs-lisp
(setq-default indent-tabs-mode  nil
        tab-width         2
        tab-always-indent 'complete)

(require 'tabify nil t)
#+end_src

*** Keep Whitespace Clean
Make whitespace uniform when saving a file. So if a line contains a mix of tabs and
spaces, this will replace it with "appropriate" whitespace symbols
#+begin_src emacs-lisp
(add-hook 'before-save-hook #'whitespace-cleanup)
#+end_src

*** Selecting Text
When you type over marked text, it should delete the text. In every other
editor it would but with emacs we have to tell it to first
#+begin_src
(delete-selection-mode t)
#+end_src

*** Autocomplete Dropdown
Company is your general purpose autocomplete dropdown. enable it always
#+begin_src emacs-lisp
(use-package company
  :diminish company-mode
  :config (progn (setq company-idle-delay 0.5
           company-show-numbers t
           company-tooltip-limit 10
           company-minimum-prefix-length 2
           company-tooltip-align-annotations t
           ;; invert the navigation direction if the the completion popup-isearch-match
           ;; is displayed on top (happens near the bottom of windows)
           company-tooltip-flip-when-above t)
     (global-company-mode 1)))
#+end_src

*** Highlighting
**** Search Results
Highlight search results
#+begin_src emacs-lisp
(setq search-highlight t
      query-replace-highlight t)
#+end_src

**** Show Paren
Highlight matching parens.
#+begin_src emacs-lisp
(show-paren-mode t)
(set-face-foreground 'show-paren-match "DimGrey")
#+end_src
***** TODO monokai-theme overwrites this value with custom fix this.

**** Rainbow Mode
Highlight strings which probably represent a colour as the colour they probably represent.
e.g red DarkGreen, #2449FC
#+begin_src emacs-lisp
(use-package rainbow-mode
  :diminish rainbow-mode
  :config (rainbow-mode t))
#+end_src

** X Windows
*** Colour Scheme
Bright colours on a dull background. very pleasing on the eyes. Only load when in a window-system because it
looks horrible on a typical terminal
#+begin_src emacs-lisp
(use-package monokai-theme
  :if window-system
  :config (load-theme 'monokai t))
#+end_src

*** Mode Line Eyecandy - Spaceline
Spaceline is a nice looking modeline package based on powerline from the [[http://spacemacs.org/][spacemacs]] distribution
#+begin_src emacs-lisp
(use-package spaceline
  :if window-system
  :config (progn (setq powerline-default-separator 'contour)
     (spaceline-emacs-theme)))
#+end_src
**** TODO Spaceline all-the-icons

*** Window Divider
Make the vertical window divider available but only one pixel wide
#+begin_src emacs-lisp
(when window-system
  (setq window-divider-default-right-width 1)
  (window-divider-mode t))
#+end_src

*** Transparency
I like the "glass editing window" effect. This sets it that way by default and gives a function to toggle it.
#+begin_src emacs-lisp
(when window-system
  (defun mkyle/toggle-transparency ()
    "Toggle off window transparency"
    (interactive)
    (set-frame-parameter nil 'alpha
   (if (eql (car (frame-parameter nil 'alpha))
      100)
       '(95 . 95)
         '(100 . 100))))

  (set-frame-parameter nil 'alpha '(95 . 95)))
#+end_src

*** TODO Emojis

* Major Modes
** Git
A version control tool created by Linus Torvalds

*** Magit
Magit is nice frontend to git. C-c m to open magit-status popup
#+begin_src emacs-lisp
(use-package magit
  :defer t
  :config (global-set-key (kbd "C-c m") 'magit-status))
#+end_src

*** Git file modes
Modes for editing git files e.g =.gitignore=
#+begin_src emacs-lisp
(use-package git-modes)
#+end_src

*** Mergetool
To use emacs as a git mergetool, you need to add something like the following to =~/.gitconfig=
#+begin_src conf
[mergetool.ediff]
  cmd = emacsclient --eval \"(ediff-merge-files-with-ancestor \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" nil \\\"$MERGED\\\")\"
[merge]
  tool = ediff
#+end_src

Cleanup ediff buffers and restore window configuration when finished
#+begin_src emacs-lisp
(with-eval-after-load "ediff"
  ;; TODO this fails when ediff complains about a buffer already open for a file being merged
  (defun mkyle/ediff-janitor ()
    "Delete buffers and restore window on ediff exit."
    (let* ((ctl-buf ediff-control-buffer)
     (ctl-win (ediff-get-visible-buffer-window ctl-buf))
     (ctl-frm ediff-control-frame)
     (main-frame (cond ((window-live-p ediff-window-A)
            (window-frame ediff-window-A))
           ((window-live-p ediff-window-B)
            (window-frame ediff-window-B)))))
      (ediff-kill-buffer-carefully ediff-diff-buffer)
      (ediff-kill-buffer-carefully ediff-custom-diff-buffer)
      (ediff-kill-buffer-carefully ediff-fine-diff-buffer)
      (ediff-kill-buffer-carefully ediff-tmp-buffer)
      (ediff-kill-buffer-carefully ediff-error-buffer)
      (ediff-kill-buffer-carefully ediff-msg-buffer)
      (ediff-kill-buffer-carefully ediff-debug-buffer)
      (when (boundp 'ediff-patch-diagnostics)
  (ediff-kill-buffer-carefully ediff-patch-diagnostics))
      (cond ((and (ediff-window-display-p)
      (frame-live-p ctl-frm))
       (delete-frame ctl-frm))
      ((window-live-p ctl-win)
       (delete-window ctl-win)))
      (unless (ediff-multiframe-setup-p)
  (ediff-kill-bottom-toolbar))
      (ediff-kill-buffer-carefully ctl-buf)
      (when (frame-live-p main-frame)
  (select-frame main-frame)))
    (ediff-janitor nil nil))

  (add-hook 'ediff-cleanup-hook 'mkyle/ediff-janitor))

(use-package winner
  :config (progn (winner-mode +1)
     (with-eval-after-load "ediff"
       (add-hook 'ediff-cleanup-hook 'winner-undo))))
#+end_src

** IRC
Internet relay chat appliance for emacs. Tune erc to use utf-8, truncate long buffers, enable logging and other things.
#+begin_src emacs-lisp
(with-eval-after-load "erc"
  (setq erc-query-display 'buffer
  erc-interpret-mirc-color t
  erc-server-coding-system '(utf-8 . utf-8)
  erc-save-buffer-on-part t
  erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
          "324" "329" "332" "333" "353" "477"))

  (erc-truncate-mode +1)
  (erc-track-mode t)

  (when (require 'erc-log nil t)
    (unless (file-exists-p erc-log-channels-directory)
      (mkdir erc-log-channels-directory t)))

  (when (require 'erc-spelling nil t)
    (erc-spelling-mode 1)))
#+end_src

** Emacs Lisp
Extension language for emacs. Most useful packages for elisp are included with vanilla emacs

*** Documentation
Show documentation in the minibuffer for symbol under cursor
#+begin_src emacs-lisp
(when (require 'eldoc nil t)
  (diminish 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+end_src

*** Autocompile
Automatically compile emacs lisp files from the user configuration directory =~/.emacs.d=.

#+begin_src emacs-lisp
(use-package auto-compile
  :config (progn
      (setq auto-compile-display-buffer    nil
      auto-compile-mode-line-counter t)
      (auto-compile-on-load-mode)
      (auto-compile-on-save-mode)))

(defun mkyle/elisp-recompile-elc-on-save ()
  "Recompile your elc when saving an elisp file."
  (add-hook 'after-save-hook
      (lambda ()
        (when (and (string-prefix-p user-emacs-directory
            (file-truename buffer-file-name))
       (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (emacs-lisp-byte-compile)))
      nil
      t))

(add-hook 'emacs-lisp-mode-hook 'mkyle/elisp-recompile-elc-on-save)
#+end_src

** Conf Files
Syntax highlighting for unix config files
#+begin_src emacs-lisp
(when (require 'conf-mode nil t)
  (mapc (lambda (fname)
    (add-to-list 'auto-mode-alist `(,fname . conf-mode)))
  (list "\\.conf\\'"
        "\\.desktop\\'"
        "\\.service\\'")))
#+end_src

** Clojure
A more opinionated scheme for jvm written by Rich Hickey. Some said it wasn't possible to make a more
particular scheme; Rich aggressively disagrees.

#+begin_src emacs-lisp
(use-package clojure-mode
  :mode ("\\.edn\\'" "\\.clj\\'")
  :config (add-hook 'clojure-mode-hook 'subword-mode))
#+end_src

*** Cider
Cider is a featureful repl for clojure development
#+begin_src emacs-lisp
(use-package cider
  :config (progn
      (setq nrepl-log-messages t)
      (add-hook 'cider-mode-hook #'eldoc-mode)
      (add-hook 'cider-repl-mode-hook #'subword-mode)
      (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
      (add-hook 'cider-repl-mode-hook #'company-mode)
      (add-hook 'cider-mode-hook #'company-mode)

      (with-eval-after-load "ibuffer-dynamic-groups"
        (ibuffer-dynamic-groups-add
    (lambda (groups)
      (append '(("Cider" (or (name . "^\\*nrepl-.*\\*$")
           (name . "^\\*cider-.*\\*$"))))
        groups))
         '((name . cider-group)
     (depth . -1))))))
#+end_src

** CMake
It's like make only less accessible to new users. you're welcome. - GNU, probably

#+begin_src emacs-lisp
(use-package cmake-mode
  :defer t
  :mode ("CMakeLists\\.txt\\'" "\\.cmake\\'"))
#+end_src

** JavaScript
The most fully featured language for running in the web browser and I wish I was joking.

#+begin_src emacs-lisp
(use-package js2-mode
  :defer t
  :mode ("\\.js\\'" "\\.pac\\'")
  :interpreter "node")

(use-package json-mode
  :defer t
  :mode "\\.json\\'")
#+end_src

** Scheme
Like clojure but old. GNU's trying to bring it back with GNU/Guile. power to them.

#+begin_src emacs-lisp
(use-package scheme
  :defer t
  :mode ("\\.scm\\'" . scheme-mode))
#+end_src

You really need to have a repl open when editing scheme files. Geiser is a nice one for emacs. invoke with =geiser=
#+begin_src emacs-lisp
(use-package geiser
  :config (setq geiser-mode-start-repl-p t))
#+end_src

** Groovy
Don't get much use out of groovy syntax highlighting but it's useful for editing Jenkinsfiles
#+begin_src emacs-lisp
(use-package groovy-mode
  :defer t
  :mode ("\\.groovy\\'" "JenkinsFile\\'"))
#+end_src

** Docker
Dockerfile syntax highlighting
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :defer t
  :mode "Dockerfile\\'")
#+end_src

** YAML
Seriously if you have the choice, use json or even edn. If you don't, here's some syntax highlighting for yaml.
#+begin_src emacs-lisp
(use-package yaml-mode
  :defer t
  :mode ("\\.yaml\\'" "\\.yml\\'"))
#+end_src

** Markdown
Like org but not as cool
#+begin_src emacs-lisp
(use-package markdown-mode
  :defer t
  :mode ("\\.md\\'" "\\.markdown\\'"))
#+end_src

** Lua
Because 'X' won't mod itself
#+begin_src emacs-lisp
(use-package lua-mode
  :defer t
  :mode "\\.lua\\'")
#+end_src

** Zsh
Interpret the *many* zsh configuration scripts as zsh and recognize the =.zsh= file extension
#+begin_src emacs-lisp
(when (require 'sh-script nil t)
  (let ((zsh-files '("zlogin" "zlogin" "zlogout" "zpreztorc" "zprofile" "zshenv" "zshrc" ".zsh")))
    (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
    (mapc (lambda (file)
      (add-to-list 'auto-mode-alist `(,(format "\\%s\\'" file) . sh-mode)))
    zsh-files)
    (add-hook 'sh-mode-hook
        (lambda ()
    (if (and buffer-file-name
        (member (file-name-nondirectory buffer-file-name) zsh-files))
      (sh-set-shell "zsh"))))))
#+end_src

** Terraform
Because why use something everyone's familiar with when you can create your own domain specific language?
#+begin_src emacs-lisp
(use-package terraform-mode
  :defer t
  :mode ("\\.tf\\'" "\\.tvars\\'"))
#+end_src

* Window Manager EXWM
"You did it. You're free" - Janet Carr, sarcastically, when I told her I started using emacs as a window
manager.

This section is pretty messy and not very likely to be reused. Maybe someday I will come back, clean up,
and document it.

#+begin_src emacs-lisp
(defmacro wm/define-launcher (fun-name command-and-args)
      "Define an interactive function that invokes the shell command given"
      `(defun ,fun-name ()
   (interactive)
   (start-process-shell-command "" nil ,command-and-args)))

(use-package exwm
  :if window-system
  :config
  (progn
    (require 'exwm-config)
    (require 'exwm-randr)
    (require 'exwm-systemtray)

    (with-eval-after-load "ibuffer-dynamic-groups"
  (ibuffer-dynamic-groups-add (lambda (groups)
              (append '(("X Windows" (mode . exwm-mode)))
                groups))
            '((name . exwm-group)
              (depth . -10))))

    ;; Dialog boxes do not work with exwm
    (setq use-dialog-box nil)
    (setq display-time-day-and-date t)
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    (defvar wm/tmux-session-name "0")

    (defun wm/no-op ()
      "Used to suppress warnings for shortcut keys that already work in hardware"
      (interactive))

    ;; Launchers

    (defun wm/run-sh-async (command)
      "Interactive prompt to run a shell command in a child process which may or may not spawn an x window"
      (interactive (list (read-shell-command "$ ")))
      (start-process-shell-command "" nil command))

    (defun wm/run-tmux (command)
      "Run a command in a new window of the tmux session"
      (interactive (list (read-shell-command "[tmux]$ ")))
      (start-process-shell-command ""
     nil
     (concat "terminator -e 'tmux new-session -AD -c $HOME -s "
       wm/tmux-session-name
       "\\; new-window -c $(pwd) \""
       command
       "\"'")))


    (wm/define-launcher wm/browser (or (getenv "X_BROWSER")
         "firefox"))
    (wm/define-launcher wm/tmux-shell-here (concat "terminator -e 'tmux new-session -AD -c $HOME -s \""
         wm/tmux-session-name
         "\" \\; new-window -c $(pwd) /usr/bin/zsh'"))
    (wm/define-launcher wm/term (concat "terminator -e 'tmux new-session -AD -c $HOME -s \""
    wm/tmux-session-name
    "\"'"))
    (wm/define-launcher wm/volume-manager "terminator --title Volume -e 'pulsemixer || alsamixer'")
    (wm/define-launcher wm/volume-up "amixer set Master 5%+")
    (wm/define-launcher wm/volume-down "amixer set Master 5%-")
    (wm/define-launcher wm/mute-toggle "amixer set Master toggle")
    (wm/define-launcher wm/mute-mic "amixer set Mic toggle")
    (wm/define-launcher wm/scrot "scrot --select --exec 'mv $f ~/Pictures/screenshots'")
    (wm/define-launcher wm/lock "dm-tool lock")
    (wm/define-launcher wm/music-toggle "mpc toggle")
    (wm/define-launcher wm/music-next "mpc next")
    (wm/define-launcher wm/music-prev "mpc prev")
    (wm/define-launcher wm/music-manager "terminator -e 'ncmpcpp -s playlist -S visualizer'")

    ;; TODO get windmove integration working better
    (with-eval-after-load "windmove"
      (use-package framemove
  :config (progn ;; windmove with framemove integration
      (defun wm/frame-move (dir)
        (pcase dir
          ('up (fm-up-frame))
          ('down (fm-down-frame))
          ('left (fm-left-frame))
          ('right (fm-right-frame))))

      (defun wm/do-window-select (dir &optional arg window)
        "Move to the window at direction DIR.
DIR, ARG, and WINDOW are handled as by `windmove-other-window-loc'.
If no window is at direction DIR, an error is signaled."
        (let ((other-window (windmove-find-other-window dir arg window)))
          (cond ((null other-window)
           (wm/frame-move dir))
          ((and (window-minibuffer-p other-window)
          (not (minibuffer-window-active-p other-window)))
           (wm/frame-move dir))
          (t
           (select-window other-window)))))

      (defun wm/move-left (&optional arg)
  (interactive "P")
  (wm/do-window-select 'left arg))

      (defun wm/move-up (&optional arg)
  (interactive "P")
  (wm/do-window-select 'up arg))

      (defun wm/move-right (&optional arg)
  (interactive "P")
  (wm/do-window-select 'right arg))

      (defun wm/move-down (&optional arg)
  (interactive "P")
  (wm/do-window-select 'down arg))

      (exwm-input-set-key (kbd "s-<left>") #'wm/move-left)
      (exwm-input-set-key (kbd "s-<right>") #'wm/move-right)
      (exwm-input-set-key (kbd "s-<up>") #'wm/move-up)
      (exwm-input-set-key (kbd "s-<down>") #'wm/move-down))))


    (defun wm/insert (string)
      "Send `string' to clipboard and then send C-v to application to hopefully
trigger the paste operation, `string' will be inserted into the application."
      (if (derived-mode-p 'exwm-mode)
    (progn
      (kill-new string)
      (dolist (key (string-to-list (kbd "\C-v")))
  (exwm-input--fake-key key))
      (setq kill-ring (cdr kill-ring)))
  (insert string)))

    (defun wm/xrandr-update-outputs ()
      (let ((connected-monitors (car
   (read-from-string
    ;; TODO write in el
    (shell-command-to-string
     "xrandr | awk 'BEGIN {print \"(\"}
    / connected/ {print \"\\\"\" $1 \"\\\"\"}
    END {print \")\"}'"))))
      (i -1))
  (setq exwm-randr-workspace-monitor-plist (cl-reduce (lambda (acc s)
        (setq i (+ i 1))
        (append acc (list i s)))
      connected-monitors
      :initial-value '()))
  (setq i (+ i 1))
  (while (> i (exwm-workspace--count))
    (exwm-workspace-add))
  (while (< i (exwm-workspace--count))
    (exwm-workspace-delete (- (exwm-workspace--count) 1)))))

    (defun wm/rename-buffer ()
      (interactive)
      (exwm-workspace-rename-buffer

       (concat exwm-class-name ": "
   (if (<= (length exwm-title) 50)
       exwm-title
     (concat (substring exwm-title 0 49) "...")))))

    (add-hook 'exwm-update-class-hook 'wm/rename-buffer)
    (add-hook 'exwm-update-title-hook 'wm/rename-buffer)

    (defun wm/xrandr-init ()
      (add-hook 'exwm-randr-screen-change-hook 'wm/xrandr-update-outputs)
      (wm/xrandr-update-outputs)
      (exwm-randr--init))

    (defun wm/xrandr-exit ()
      (remove-hook 'exwm-randr-screen-change-hook 'wm/xrandr-update-outputs)
      (exwm-randr--exit))

    (add-hook 'exwm-init-hook #'wm/xrandr-init)
    (add-hook 'exwm-exit-hook #'wm/xrandr-exit)

    (when (require 'ido nil t)
      (exwm-input-set-key (kbd "s-x b") #'ido-switch-buffer)
      (exwm-config-ido))

    (exwm-input-set-key (kbd "s-SPC") #'exwm-input-toggle-keyboard)

    ;; Do stuff
    (exwm-input-set-key (kbd "s-`") #'wm/run-sh-async)
    (exwm-input-set-key (kbd "s-!") #'wm/run-tmux)
    (exwm-input-set-key (kbd "s-x s-x") #'execute-extended-command)

    ;; Navigation
    (exwm-input-set-key (kbd "M-<tab>") #'previous-buffer)
    (exwm-input-set-key (kbd "M-<iso-lefttab>") #'next-buffer)
    (exwm-input-set-key (kbd "M-<left>") #'previous-buffer)
    (exwm-input-set-key (kbd "M-<right>") #'next-buffer)

    ;; Cheating
    (exwm-input-set-key (kbd "s-x s-b") #'ibuffer)

    ;; Apps
    (exwm-input-set-key (kbd "s-x i") #'wm/browser)
    (exwm-input-set-key (kbd "s-x <return>") #'wm/tmux-shell-here)
    (exwm-input-set-key (kbd "s-x v") #'wm/volume-manager)
    (exwm-input-set-key (kbd "s-x l") #'wm/lock)
    (exwm-input-set-key (kbd "s-l") #'wm/lock)
    (exwm-input-set-key (kbd "s-<return>") #'wm/term)

    (exwm-input-set-key (kbd "s-x m") #'wm/music-manager)
    (exwm-input-set-key (kbd "s-x <down>") #'wm/music-toggle)
    (exwm-input-set-key (kbd "s-x <left>") #'wm/music-prev)
    (exwm-input-set-key (kbd "s-x <right>") #'wm/music-next)

    (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>") #'wm/volume-up)
    (exwm-input-set-key (kbd "<XF86AudioLowerVolume>") #'wm/volume-down)
    (exwm-input-set-key (kbd "<XF86AudioMute>") #'wm/mute-toggle)
    (exwm-input-set-key (kbd "<XF86AudioMicMute>") #'wm/mute-mic)
    (exwm-input-set-key (kbd "<XF86AudioPlay>") #'wm/music-toggle)
    (exwm-input-set-key (kbd "<XF86AudioNext>") #'wm/music-next)
    (exwm-input-set-key (kbd "<XF86AudioPrev>") #'wm/music-prev)
    (exwm-input-set-key (kbd "<XF86Launch1>") #'wm/scrot)
    (exwm-input-set-key (kbd "<XF86ScreenSaver>") #'wm/lock)
    (exwm-input-set-key (kbd "<XF86LaunchA>") #'wm/music-toggle)
    (exwm-input-set-key (kbd "<XF86Search>") #'wm/music-prev)
    (exwm-input-set-key (kbd "<XF86Explorer>") #'wm/music-next)

    ;; These work in hardware so don't need warning about undefined
    (exwm-input-set-key (kbd "<XF86MonBrightnessDown>") #'wm/no-op)
    (exwm-input-set-key (kbd "<XF86MonBrightnessUp>") #'wm/no-op)
    (exwm-input-set-key (kbd "<XF86Sleep>") #'wm/no-op)
    (exwm-input-set-key (kbd "<XF86WLAN>") #'wm/no-op)

    ;; Keybind to send emacs bound keys to x window while in line mode
    (exwm-input-set-key (kbd "C-q") #'exwm-input-send-next-key)

    (display-time-mode t)
    (display-battery-mode t)
    (exwm-systemtray-enable)))
#+end_src

* Footer
Add a marker so we know where the file is intended to end
#+begin_src emacs-lisp
;; init.el ends here
#+end_src
# readme.org ends here
